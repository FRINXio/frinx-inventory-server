### This file was generated by Nexus Schema
### Do not make changes to this file directly

type ActivateStreamPayload {
  stream: Stream!
}

input AddBlueprintInput {
  name: String!
  template: String!
}

type AddBlueprintPayload {
  blueprint: Blueprint!
}

input AddDeviceInput {
  address: String
  blueprintId: String
  deviceSize: DeviceSize
  deviceType: String
  labelIds: [String!]
  locationId: String
  model: String
  mountParameters: String
  name: String!
  password: String
  port: Int
  serviceState: DeviceServiceState
  username: String
  vendor: String
  version: String
  zoneId: String!
}

type AddDevicePayload {
  device: Device!
}

input AddLocationInput {
  coordinates: Coordinates!
  countryId: String
  name: String!
}

type AddLocationPayload {
  location: Location!
}

input AddSnapshotInput {
  deviceId: String!
  name: String!
}

type AddSnapshotPayload {
  snapshot: Snapshot
}

input AddStreamInput {
  blueprintId: String
  deviceName: String!
  streamName: String!
  streamParameters: String
}

type AddStreamPayload {
  stream: Stream!
}

input AddZoneInput {
  name: String!
}

type AddZonePayload {
  zone: Zone!
}

input ApplySnapshotInput {
  deviceId: String!
  name: String!
}

type ApplySnapshotPayload {
  isOk: Boolean!
}

interface BaseGraphNode {
  coordinates: GraphNodeCoordinates!
  deviceType: String
  id: ID!
  interfaces: [GraphNodeInterface!]!
  softwareVersion: String
}

type Blueprint implements Node {
  createdAt: String!
  id: ID!
  name: String!
  template: String!
  updatedAt: String!
}

type BlueprintConnection {
  edges: [BlueprintEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BlueprintEdge {
  cursor: String!
  node: Blueprint!
}

type BulkInstallDevicePayload {
  installedDevices: [Device!]!
}

input BulkInstallDevicesInput {
  deviceIds: [String!]!
}

type BulkInstallStreamPayload {
  installedStreams: [Stream!]!
}

input BulkInstallStreamsInput {
  streamIds: [String!]!
}

type BulkUninstallDevicePayload {
  uninstalledDevices: [Device!]!
}

input BulkUninstallDevicesInput {
  deviceIds: [String!]!
}

type BulkUninstallStreamPayload {
  uninstalledStreams: [Stream!]!
}

input BulkUninstallStreamsInput {
  streamIds: [String!]!
}

type CSVImport {
  isOk: Boolean
}

input CSVImportInput {
  file: Upload!
  zoneId: String!
}

type CalculatedDiffPayload {
  result: CalculatedDiffResult!
}

type CalculatedDiffResult {
  createdData: [DiffData!]!
  deletedData: [DiffData!]!
  updatedData: [CalculatedUpdateDiffData!]!
}

type CalculatedUpdateDiffData {
  actualData: String!
  intendedData: String!
  path: String!
}

type CloseTransactionPayload {
  isOk: Boolean!
}

input CommitConfigInput {
  deviceId: String!
  shouldDryRun: Boolean
}

type CommitConfigOutput {
  configuration: String
  deviceId: String!
  message: String
}

type CommitConfigPayload {
  output: CommitConfigOutput!
}

input Coordinates {
  latitude: Float!
  longitude: Float!
}

type Country implements Node {
  code: String!
  id: ID!
  name: String!
}

type CountryConnection {
  edges: [CountryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CountryEdge {
  cursor: String!
  node: Country!
}

input CreateLabelInput {
  name: String!
}

type CreateLabelPayload {
  label: Label
}

type CreateTransactionPayload {
  transactionId: String
}

type DataStore {
  config: String!
  operational: String!
  snapshots: [Snapshot!]!
}

type DeactivateStreamPayload {
  stream: Stream!
}

type DeleteBlueprintPayload {
  blueprint: Blueprint
}

type DeleteDevicePayload {
  device: Device
}

type DeleteLabelPayload {
  label: Label
}

type DeleteLocationPayload {
  location: Location!
}

input DeleteSnapshotInput {
  deviceId: String!
  name: String!
  transactionId: String!
}

type DeleteSnapshotPayload {
  snapshot: Snapshot
}

type DeleteStreamPayload {
  stream: Stream
}

type Device implements Node {
  address: String
  blueprint: Blueprint
  createdAt: String!
  deviceSize: DeviceSize!
  discoveredAt: String
  id: ID!
  isInstalled: Boolean!
  labels(after: String, before: String, first: Int, last: Int): LabelConnection!
  location: Location
  model: String
  mountParameters: String
  name: String!
  port: Int
  serviceState: DeviceServiceState!
  software: String
  source: DeviceSource!
  updatedAt: String!
  vendor: String
  version: String
  zone: Zone!
}

type DeviceConnection {
  edges: [DeviceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeviceDiscoveryPayload {
  deviceId: String!
  discoveredAt: String
}

type DeviceEdge {
  cursor: String!
  node: Device!
}

type DeviceListUsage {
  devicesUsage: [DevicesUsage!]!
}

type DeviceMetadata {
  nodes: [GeoMapDevice]
}

input DeviceOrderByInput {
  direction: SortDirection!
  sortKey: SortDeviceBy!
}

enum DeviceServiceState {
  IN_SERVICE
  OUT_OF_SERVICE
  PLANNING
}

enum DeviceSize {
  LARGE
  MEDIUM
  SMALL
}

enum DeviceSource {
  DISCOVERED
  IMPORTED
  MANUAL
}

type DeviceStatus {
  deviceName: String
  status: String
}

type DeviceUsage {
  cpuLoad: Float
  memoryLoad: Float
}

type DevicesConnection {
  deviceStatuses: [DeviceStatus]
}

type DevicesUsage {
  cpuLoad: Float
  deviceName: String!
  memoryLoad: Float
}

type DiffData {
  data: String!
  path: String!
}

type EdgeSourceTarget {
  interface: String!
  nodeId: String!
}

input FilterDevicesInput {
  deviceName: String
  labels: [String!]
}

input FilterLabelsInput {
  name: String!
}

input FilterStreamsInput {
  deviceName: String
  labels: [String!]
  streamName: String
}

input FilterTopologyInput {
  labels: [String!]
}

input FilterZonesInput {
  name: String!
}

type GeoMapDevice {
  deviceName: String!
  geolocation: Geolocation
  id: ID!
  locationName: String
}

type Geolocation {
  latitude: Float!
  longitude: Float!
}

type GraphEdge {
  id: ID!
  source: EdgeSourceTarget!
  target: EdgeSourceTarget!
  weight: Int
}

enum GraphEdgeStatus {
  ok
  unknown
}

type GraphNode implements BaseGraphNode {
  coordinates: GraphNodeCoordinates!
  device: Device
  deviceType: String
  id: ID!
  interfaces: [GraphNodeInterface!]!
  name: String!
  softwareVersion: String
}

type GraphNodeCoordinates {
  x: Float!
  y: Float!
}

input GraphNodeCoordinatesInput {
  deviceName: String!
  x: Float!
  y: Float!
}

type GraphNodeInterface {
  id: String!
  name: String!
  status: GraphEdgeStatus!
}

type GraphVersionEdge {
  id: ID!
  source: EdgeSourceTarget!
  target: EdgeSourceTarget!
}

type GraphVersionNode implements BaseGraphNode {
  coordinates: GraphNodeCoordinates!
  deviceType: String
  id: ID!
  interfaces: [GraphNodeInterface!]!
  name: String!
  softwareVersion: String
}

type InstallDevicePayload {
  device: Device!
}

type IsOkResponse {
  isOk: Boolean!
}

type Label implements Node {
  createdAt: String!
  id: ID!
  name: String!
  updatedAt: String!
}

type LabelConnection {
  edges: [LabelEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LabelEdge {
  cursor: String!
  node: Label!
}

type Location implements Node {
  country: String
  createdAt: String!
  id: ID!
  latitude: Float
  longitude: Float
  name: String!
  updatedAt: String!
}

type LocationConnection {
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LocationEdge {
  cursor: String!
  node: Location!
}

type LspTunnel {
  fromDevice: String
  lspId: String!
  signalization: Signalization
  toDevice: String
  uptime: Int
}

type MplsData {
  inputInterface: String
  inputLabel: Int
  lspId: String!
  outputInterface: String
  outputLabel: Int
}

type MplsDeviceDetails {
  lspTunnels: [LspTunnel]
  mplsData: [MplsData]
}

type MplsGraphNode {
  coordinates: GraphNodeCoordinates!
  id: ID!
  interfaces: [MplsGraphNodeInterface!]!
  labels: [String!]
  mplsDeviceDetails: MplsDeviceDetails!
  name: String!
  nodeId: String!
  status: GraphEdgeStatus!
}

type MplsGraphNodeInterface {
  id: String!
  name: String!
  status: GraphEdgeStatus!
}

type MplsTopology {
  edges: [GraphEdge!]!
  nodes: [MplsGraphNode!]!
}

type Mutation {
  activateStream(id: String!): ActivateStreamPayload!
  addBlueprint(input: AddBlueprintInput!): AddBlueprintPayload!
  addDevice(input: AddDeviceInput!): AddDevicePayload!
  addLocation(input: AddLocationInput!): AddLocationPayload!
  addSnapshot(input: AddSnapshotInput!, transactionId: String!): AddSnapshotPayload
  addStream(input: AddStreamInput!): AddStreamPayload!
  addZone(input: AddZoneInput!): AddZonePayload!
  applySnapshot(input: ApplySnapshotInput!, transactionId: String!): ApplySnapshotPayload!
  bulkInstallDevices(input: BulkInstallDevicesInput!): BulkInstallDevicePayload!
  bulkInstallStreams(input: BulkInstallStreamsInput!): BulkInstallStreamPayload!
  bulkUninstallDevices(input: BulkUninstallDevicesInput!): BulkUninstallDevicePayload!
  bulkUninstallStreams(input: BulkUninstallStreamsInput!): BulkUninstallStreamPayload!
  closeTransaction(deviceId: String!, transactionId: String!): CloseTransactionPayload!
  commitConfig(input: CommitConfigInput!, transactionId: String!): CommitConfigPayload!
  createLabel(input: CreateLabelInput!): CreateLabelPayload!
  createTransaction(deviceId: String!): CreateTransactionPayload!
  deactivateStream(id: String!): DeactivateStreamPayload!
  deleteBlueprint(id: String!): DeleteBlueprintPayload!
  deleteDevice(id: String!): DeleteDevicePayload!
  deleteLabel(id: String!): DeleteLabelPayload!
  deleteLocation(id: String!): DeleteLocationPayload!
  deleteSnapshot(input: DeleteSnapshotInput!): DeleteSnapshotPayload
  deleteStream(id: String!): DeleteStreamPayload!
  importCSV(input: CSVImportInput!): CSVImport
  installDevice(id: String!): InstallDevicePayload!
  reconnectKafka: IsOkResponse
  resetConfig(deviceId: String!, transactionId: String!): ResetConfigPayload!
  revertChanges(transactionId: String!): RevertChangesPayload!
  syncFromNetwork(deviceId: String!, transactionId: String!): SyncFromNetworkPayload!
  uninstallDevice(id: String!): UninstallDevicePayload!
  updateBlueprint(id: String!, input: UpdateBlueprintInput!): UpdateBlueprintPayload!
  updateDataStore(deviceId: String!, input: UpdateDataStoreInput!, transactionId: String!): UpdateDataStorePayload!
  updateDevice(id: String!, input: UpdateDeviceInput!): UpdateDevicePayload!
  updateDiscoveredAt(deviceIds: [String!]!): [DeviceDiscoveryPayload!]!
  updateGraphNodeCoordinates(input: UpdateGraphNodeCoordinatesInput!): UpdateGraphNodeCoordinatesPayload!
  updateLocation(id: String!, input: UpdateLocationInput!): UpdateLocationPayload!
  updateStream(id: String!, input: UpdateStreamInput!): UpdateStreamPayload!
}

type NetInterface {
  id: String!
  name: String!
}

type NetNetwork {
  coordinates: GraphNodeCoordinates!
  id: String!
  subnet: String!
}

type NetNode {
  coordinates: GraphNodeCoordinates!
  id: ID!
  interfaces: [NetInterface!]!
  name: String!
  networks: [NetNetwork!]!
  nodeId: String!
}

type NetRoutingPathNode {
  nodes: [NetRoutingPathNodeInfo!]!
  weight: Int
}

type NetRoutingPathNodeInfo {
  name: String
  weight: Int
}

type NetTopology {
  edges: [GraphEdge!]!
  nodes: [NetNode!]!
}

type NetTopologyVersionData {
  edges: [GraphVersionEdge!]!
  nodes: [NetNode!]!
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PhyTopologyVersionData {
  edges: [GraphVersionEdge!]!
  nodes: [GraphVersionNode!]!
}

input PolygonInput {
  polygon: [[[Float!]!]!]
}

type PtpDeviceDetails {
  clockAccuracy: String
  clockClass: Int
  clockId: String
  clockType: String
  clockVariance: String
  domain: Int
  globalPriority: Int
  gmClockId: String
  parentClockId: String
  ptpProfile: String
  timeRecoveryStatus: String
  userPriority: Int
}

type PtpDiffSynce {
  edges: [PtpDiffSynceEdges!]!
}

type PtpDiffSynceEdges {
  node: PtpDiffSynceNode!
}

type PtpDiffSynceNode {
  id: String!
}

type PtpGraphNode {
  coordinates: GraphNodeCoordinates!
  id: ID!
  interfaces: [PtpGraphNodeInterface!]!
  labels: [String!]
  name: String!
  nodeId: String!
  ptpDeviceDetails: PtpDeviceDetails!
  status: GraphEdgeStatus!
}

type PtpGraphNodeInterface {
  details: PtpGraphNodeInterfaceDetails
  id: String!
  name: String!
  status: GraphEdgeStatus!
}

type PtpGraphNodeInterfaceDetails {
  adminOperStatus: String!
  ptpStatus: String!
  ptsfUnusable: String!
}

type PtpTopology {
  edges: [GraphEdge!]!
  nodes: [PtpGraphNode!]!
}

type PtpTopologyVersionData {
  edges: [GraphVersionEdge!]!
  nodes: [PtpGraphNode!]!
}

type Query {
  blueprints(after: String, before: String, first: Int, last: Int): BlueprintConnection!
  calculatedDiff(deviceId: String!, transactionId: String!): CalculatedDiffPayload!
  countries(after: String, before: String, first: Int, last: Int): CountryConnection!
  dataStore(deviceId: String!, transactionId: String!): DataStore
  deviceMetadata(deviceName: String, polygon: PolygonInput, topologyType: TopologyType): DeviceMetadata
  devices(
    after: String
    before: String
    filter: FilterDevicesInput
    first: Int
    last: Int
    orderBy: DeviceOrderByInput
  ): DeviceConnection!
  kafkaHealthCheck: IsOkResponse
  labels(after: String, before: String, filter: FilterLabelsInput, first: Int, last: Int): LabelConnection!
  locations(after: String, before: String, first: Int, last: Int): LocationConnection!
  mplsTopology: MplsTopology
  netTopology: NetTopology
  netTopologyVersionData(version: String!): NetTopologyVersionData!
  node(id: ID!): Node
  phyTopologyVersionData(version: String!): PhyTopologyVersionData!
  ptpDiffSynce: PtpDiffSynce!
  ptpPathToGrandMaster(deviceFrom: String!): [String!]
  ptpTopology: PtpTopology
  ptpTopologyVersionData(version: String!): PtpTopologyVersionData!
  shortestPath(from: String!, to: String!): [NetRoutingPathNode!]!
  streams(
    after: String
    before: String
    filter: FilterStreamsInput
    first: Int
    last: Int
    orderBy: StreamOrderByInput
  ): StreamConnection!
  syncePathToGrandMaster(deviceFrom: String!): [String!]
  synceTopology: SynceTopology
  synceTopologyVersionData(version: String!): SynceTopologyVersionData!
  topology(filter: FilterTopologyInput): Topology
  topologyCommonNodes(nodes: [String!]!): TopologyCommonNodes
  topologyVersions: [String!]
  transactions: [Transaction!]!
  uniconfigShellSession: String
  zones(after: String, before: String, filter: FilterZonesInput, first: Int, last: Int): ZonesConnection!
}

type ResetConfigPayload {
  dataStore: DataStore!
}

type RevertChangesPayload {
  isOk: Boolean!
}

enum Signalization {
  LDP
  RSVP
}

type Snapshot {
  createdAt: String!
  name: String!
}

enum SortDeviceBy {
  discoveredAt
  modelVersion
  name
}

enum SortDirection {
  ASC
  DESC
}

enum SortStreamBy {
  createdAt
  deviceName
  streamName
}

type Stream implements Node {
  blueprint: Blueprint
  createdAt: String!
  deviceName: String!
  id: ID!
  isActive: Boolean!
  startedAt: String
  stoppedAt: String
  streamName: String!
  streamParameters: String
  updatedAt: String!
}

type StreamConnection {
  edges: [StreamEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type StreamEdge {
  cursor: String!
  node: Stream!
}

input StreamOrderByInput {
  direction: SortDirection!
  sortKey: SortStreamBy!
}

type Subscription {
  deviceUsage(deviceName: String!, refreshEverySec: Int): DeviceUsage
  devicesConnection(connectionTimeout: Int, targetDevices: [String!]!): DevicesConnection
  devicesUsage(deviceNames: [String!]!, refreshEverySec: Int): DeviceListUsage
  uniconfigShell(input: String, sessionId: String!, trigger: Int): String
}

type SyncFromNetworkPayload {
  dataStore: DataStore
}

type SynceDeviceDetails {
  selectedForUse: String
}

type SynceGraphNode {
  coordinates: GraphNodeCoordinates!
  id: ID!
  interfaces: [SynceGraphNodeInterface!]!
  labels: [String!]
  name: String!
  nodeId: String!
  status: GraphEdgeStatus!
  synceDeviceDetails: SynceDeviceDetails!
}

type SynceGraphNodeInterface {
  details: SynceGraphNodeInterfaceDetails
  id: String!
  name: String!
  status: GraphEdgeStatus!
}

type SynceGraphNodeInterfaceDetails {
  notQualifiedDueTo: String
  notSelectedDueTo: String
  qualifiedForUse: String
  rxQualityLevel: String
  synceEnabled: Boolean
}

type SynceTopology {
  edges: [GraphEdge!]!
  nodes: [SynceGraphNode!]!
}

type SynceTopologyVersionData {
  edges: [GraphVersionEdge!]!
  nodes: [SynceGraphNode!]!
}

type Topology {
  edges: [GraphEdge!]!
  nodes: [GraphNode!]!
}

type TopologyCommonNodes {
  commonNodes: [String!]!
}

enum TopologyLayer {
  EthTopology
  MplsTopology
  PhysicalTopology
  PtpTopology
}

enum TopologyType {
  EthTopology
  MplsTopology
  NetworkTopology
  PhysicalTopology
  PtpTopology
}

type Transaction {
  changes: [TransactionChange!]!
  lastCommitTime: String!
  transactionId: String!
}

type TransactionChange {
  device: Device!
  diff: [TransactionDiff!]!
}

type TransactionDiff {
  dataAfter: String
  dataBefore: String
  path: String!
}

type UninstallDevicePayload {
  device: Device!
}

input UpdateBlueprintInput {
  name: String
  template: String
}

type UpdateBlueprintPayload {
  blueprint: Blueprint!
}

input UpdateDataStoreInput {
  config: String!
}

type UpdateDataStorePayload {
  dataStore: DataStore!
}

input UpdateDeviceInput {
  address: String
  blueprintId: String
  deviceSize: DeviceSize
  deviceType: String
  labelIds: [String!]
  locationId: String
  model: String
  mountParameters: String
  password: String
  port: Int
  serviceState: DeviceServiceState
  username: String
  vendor: String
  version: String
}

type UpdateDeviceMetadataPayload {
  devices: [Device]
}

type UpdateDevicePayload {
  device: Device
}

input UpdateGraphNodeCoordinatesInput {
  coordinates: [GraphNodeCoordinatesInput!]!
  layer: TopologyLayer
}

type UpdateGraphNodeCoordinatesPayload {
  deviceNames: [String!]!
}

input UpdateLocationInput {
  coordinates: Coordinates!
  countryId: String
  name: String!
}

type UpdateLocationPayload {
  location: Location!
}

input UpdateStreamInput {
  blueprintId: String
  deviceName: String!
  streamName: String!
  streamParameters: String
}

type UpdateStreamPayload {
  stream: Stream
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

type Zone implements Node {
  createdAt: String!
  id: ID!
  name: String!
  updatedAt: String!
}

type ZoneEdge {
  cursor: String!
  node: Zone!
}

type ZonesConnection {
  edges: [ZoneEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
